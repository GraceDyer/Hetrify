# README

## Running Environment

We recommend using Docker for setting up the running environment. The provided Docker image contains all necessary tools, libraries, and experimental data, along with the Hetrify tool.

### Using Docker

To use the provided Docker environment, follow these steps:

1. **Pull the Docker image**:

    ```sh
    docker pull anonymous535/hetrify:latest
    ```

2. **Run the Docker container**:

    ```sh
    docker run -it --name hetrify_container -u root anonymous535/hetrify:latest /bin/bash
    cd ~
    ```

The Docker container includes all necessary dependencies and tools, as well as the experimental data and Hetrify tool located in the home directory.

### Manual Setup (if not using Docker)

If you prefer to set up the environment manually on Ubuntu 22.04 or a compatible Linux distribution, the following tools and libraries are required:

1. **Python 3.10**: Including `venv` and `dev` packages.
2. **CBMC 5.95**: A Bounded Model Checker for C and C++ programs.
3. **RISC-V GNU Toolchain**: For compiling and running RISC-V programs.
4. **libxml2**: A library for parsing XML documents.
5. **libelf1**: A library to handle ELF (Executable and Linkable Format) files.
6. **Python packages**: `tqdm` for progress bar and `pyelftools` for working with ELF files.
7. **Rust (rustc)**: Rust compiler with support for RISC-V architecture, enabling safe and performant cross-compilation.

To set up the environment manually, follow these steps:
```sh
# Update and install basic dependencies
sudo apt-get update
sudo apt-get install -y build-essential curl wget tar python3.10 python3.10-venv python3.10-dev bash-completion libxml2 libelf-dev python3-pip

# Install Python packages tqdm and pyelftools
pip3 install tqdm pyelftools

# Install CBMC 5.95
wget https://github.com/diffblue/cbmc/releases/download/cbmc-5.95.1/ubuntu-22.04-cbmc-5.95.1-Linux.deb
dpkg -i ubuntu-22.04-cbmc-5.95.1-Linux.deb

# Install RISC-V GNU Toolchain
wget https://github.com/riscv-collab/riscv-gnu-toolchain/releases/download/2023.01.31/riscv64-elf-ubuntu-22.04-nightly-2023.01.31-nightly.tar.gz
tar -xvf riscv64-elf-ubuntu-22.04-nightly-2023.01.31-nightly.tar.gz
sudo mv riscv64-unknown-elf /opt/riscv
echo 'export PATH=/opt/riscv/bin:$PATH' >> ~/.bashrc
source ~/.bashrc


# Install Rust and rustup
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# Add RISC-V target support
rustup target add riscv64gc-unknown-none-elf

# Verify installation
rustc --version
```



## Directory Structure

- **EX1**: Contains datasets and results for Experiment 1 in the paper, including the assembly code to be verified, the C code generated by Hetrify, and the result files.
- **EX2**: Contains datasets and results for Experiment 2 in the paper.
- **EXAMPLE**: Contains example programs from the paper.
- **Hetrify**: The verification transformation tool designed in this paper.
- **ae**: Auxiliary analysis tool for binary files. Hetrify invokes the `ae` tool during its operation.
- **Add_EX1**: Contains datasets and results for comparison experiments between Hetrify, IDA Pro, and Ghidra.
- **Add_EX2**: Contains datasets and results for the verification experiments of Rust programs.
## Supported Functions of Hetrify

Hetrify supports the transformation of the following types of code:
- Binary programs (.elf)
- RISC-V assembly programs (.s)
- C programs (.c)
- C mixed with assembly programs (.c)
- RISC-V static library code (.a)
- Rust programs (.rs)
## Basic Usage of Hetrify

Assume you want to verify the program `./bAnd1.s`. You can run Hetrify with the following command:

```sh
./Hetrify ./bAnd1.s
```

This command will generate a C program named `bAnd1_gen.c` in the `./` directory. You can then use CBMC to verify the correctness of this program.

```sh
cbmc ./bAnd1_gen.c --unwind 20
```
## Additional Functions of Hetrify

To view the additional functions and usage of Hetrify, use the following command:

```sh
./Hetrify
```

## Experiment 1

All files for Experiment 1 are stored in the `EX1` folder, including the assembly code to be verified, the C code generated by Hetrify from the assembly code, and the result files. You can use the `solve.py` script to verify the converted C programs. You can use the `solve.py` script to verify the converted C programs, the programs located in the `C/F` and `C/T` folders. 

### Example Usage

Assume you want to verify all files in the `C/F` folder with a loop unwind value of 50. You can run the following command:

```sh
cd EX1
python3 solve.py --dir C/F --unwind 50 --output F_50.csv --timeout 3000
```

After all programs are verified, a file named `F_50.csv` will be generated, recording the corresponding verification results.

## Experiment 2

All files for Experiment 2 are stored in the `EX2` folder. This experiment involves heterogeneous programs with missing critical function source code, including static libraries with missing functions, the C code generated by Hetrify from these static libraries, and the result files. You can use the `solve.py` script to verify the converted C programs. You can use the `solve.py` script to verify the converted C programs, the programs located in the `conversion/F` and `conversion/T` folders. 


### Example Usage

Assume you want to verify all files in the `conversion/T` folder with a loop unwind value of 50. You can run the following command:

```sh
cd EX2
python3 solve.py --dir conversion/T --unwind 20 --output T_20.csv --timeout 3000
```

After all programs are verified, a file named `T_20.csv` will be generated, recording the corresponding verification results.


## Additional Experiment 1

All files for Additional Experiment 1 are stored in the `Add_EX1` folder, including datasets and results for comparison experiments between Hetrify, IDA Pro, and Ghidra. The `solve.py` script is used to compare the analysis results across these tools, with input files located in the `IDA`, `Ghidra`, and `Hetrify` subfolders.

### Example Usage

Assume you want to compare all files in the `Ghidra` subfolder with the IDA Pro and Ghidra results and store the output in `T_100.csv`. You can run the following command:

```sh
cd Add_EX1
python3 solve.py --dir Ghidra/T --unwind 20 --output T_20.csv --timeout 3000
```

After running the script, a file named `T_20.csv` will be generated, containing the comparison results for each tool.

---

## Additional Experiment 2

All files for Additional Experiment 2 are stored in the `Add_EX2` folder, containing datasets and results for Rust program verification experiments. The `solve.py` script, which is specifically designed for processing Rust programs, is used for verification. Rust program files are located in the `benchmarks` folders.

### Example Usage

To verify all Rust files in the `benchmarks` folder with a loop unwind value of 50 and store the output in `result.csv`, you can use the following command:

```sh
cd Add_EX2
python3 solve.py benchmarks 
```

Once verification is complete, a file named `result.csv` will be created, recording the verification results for the Rust programs.